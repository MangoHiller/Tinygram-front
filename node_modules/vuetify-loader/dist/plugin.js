"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VuetifyLoaderPlugin = void 0;
const path = __importStar(require("upath"));
const loader_shared_1 = require("@vuetify/loader-shared");
const getVueRules_1 = require("./getVueRules");
// Can't use require.resolve() for this, it doesn't work with resolve.symlinks
let vuetifyBase;
async function getVuetifyBase(base, context, resolver) {
    if (!getVuetifyBase.promise) {
        let resolve;
        getVuetifyBase.promise = new Promise((_resolve) => resolve = _resolve);
        resolver.resolve({}, base, 'vuetify/package.json', context, (err, vuetifyPath) => {
            if (vuetifyPath) {
                vuetifyBase = path.dirname(vuetifyPath);
            }
            resolve(true);
        });
    }
    return getVuetifyBase.promise;
}
getVuetifyBase.promise = null;
class VuetifyLoaderPlugin {
    options;
    constructor(options) {
        this.options = {
            autoImport: true,
            styles: true,
            ...options,
        };
    }
    apply(compiler) {
        if (this.options.autoImport) {
            const vueRules = (0, getVueRules_1.getVueRules)(compiler);
            if (!vueRules.length) {
                throw new Error(`[VuetifyLoaderPlugin Error] No matching rule for vue-loader found.\n` +
                    `Make sure there is at least one root-level rule that uses vue-loader and VuetifyLoaderPlugin is applied after VueLoaderPlugin.`);
            }
            const rules = [...compiler.options.module.rules];
            vueRules.forEach(({ rule, index }) => {
                rule.oneOf = [
                    {
                        resourceQuery: '?',
                        use: rule.use
                    },
                    {
                        use: [
                            { loader: require.resolve('./scriptLoader') },
                            ...rule.use
                        ]
                    },
                ];
                delete rule.use;
                rules[index] = rule;
            });
            compiler.options.module.rules = rules;
        }
        if (this.options.styles === 'none' ||
            this.options.styles === 'expose') {
            compiler.options.module.rules.push({
                enforce: 'pre',
                test: /\.css$/,
                include: /node_modules[/\\]vuetify[/\\]/,
                issuer: /node_modules[/\\]vuetify[/\\]/,
                loader: 'null-loader',
            });
        }
        if (this.options.styles === 'expose') {
            function isSubdir(root, test) {
                const relative = path.relative(root, test);
                return relative && !relative.startsWith('..') && !path.isAbsolute(relative);
            }
            const files = new Set();
            let resolve;
            let promise;
            let timeout;
            async function awaitResolve() {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    resolve(true);
                }, 500);
                if (!promise) {
                    promise = new Promise((_resolve) => resolve = _resolve);
                    let start = files.size;
                    await promise;
                    if (files.size > start) {
                        await (0, loader_shared_1.writeStyles)(files);
                    }
                    promise = null;
                }
                return promise;
            }
            compiler.options.module.rules.push({
                enforce: 'pre',
                test: /\.s[ac]ss$/,
                loader: require.resolve('./styleLoader'),
                options: { awaitResolve },
            });
            compiler.options.resolve.plugins = compiler.options.resolve.plugins || [];
            compiler.options.resolve.plugins.push({
                apply(resolver) {
                    resolver
                        .getHook('resolve')
                        .tapAsync('vuetify-loader', async (request, context, callback) => {
                        if (request.path && !vuetifyBase && request.request !== 'vuetify/package.json') {
                            await getVuetifyBase(request.path, context, resolver);
                        }
                        if (!(request.path &&
                            request.request?.endsWith('.css') &&
                            isSubdir(vuetifyBase, request.path))) {
                            return callback();
                        }
                        resolver.resolve({}, request.path, request.request.replace(/\.css$/, '.sass'), context, (err, resolution) => {
                            if (resolution && !files.has(resolution)) {
                                awaitResolve();
                                files.add(resolution);
                            }
                            return callback();
                        });
                    });
                }
            });
        }
    }
}
exports.VuetifyLoaderPlugin = VuetifyLoaderPlugin;
//# sourceMappingURL=plugin.js.map